<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>俄罗斯方块 - 木头猫</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Noto Sans SC', sans-serif;
            background: #f0f0f0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 10px;
            color: #333;
            overflow: hidden;
        }
        
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: white;
            border-radius: 12px;
            padding: 15px;
            width: 100%;
            max-width: 350px;
            height: 100vh;
            max-height: 600px;
            position: relative;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            box-sizing: border-box;
            overflow: hidden;
        }
        
        h1 {
            color: #2c3e50;
            margin: 5px 0 8px;
            text-align: center;
            font-size: 1.4rem;
            font-weight: 600;
            flex-shrink: 0;
            animation: fadeIn 0.5s ease-out;
        }
        
        .stats {
            display: flex;
            justify-content: space-around;
            width: 100%;
            margin-bottom: 8px;
            background: #f8f9fa;
            padding: 8px;
            border-radius: 8px;
            font-size: 0.85rem;
            flex-shrink: 0;
            animation: slideIn 0.4s ease-out;
        }
        
        .stat-box {
            text-align: center;
        }
        
        .stat-box .label {
            color: #7f8c8d;
            font-size: 0.75rem;
            margin-bottom: 2px;
        }
        
        .stat-box .value {
            font-weight: bold;
            color: #2c3e50;
            font-size: 1rem;
        }
        
        .game-board {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            grid-template-rows: repeat(20, 1fr); /* 20行，符合10x20网格 */
            width: 100%;
            max-width: 300px; /* 设置最大宽度，确保在大屏幕上也能显示为正方形 */
            border: 2px solid #3498db;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            margin-bottom: 8px;
            padding: 2px;
            border-radius: 8px;
            position: relative;
            overflow: hidden;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.1);
            aspect-ratio: 1/2; /* 确保游戏板的宽高比为1:2，与10x20网格匹配 */
        }
        
        .game-board::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: 
                linear-gradient(rgba(52, 152, 219, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(52, 152, 219, 0.1) 1px, transparent 1px);
            background-size: calc(100% / 10) calc(100% / 20); /* 确保网格线间距一致，每个单元格一个网格线 */
            pointer-events: none;
            z-index: 0;
        }
        
        .cell {
            width: 100%;
            padding-top: 100%; /* 使用padding-top: 100%确保单元格是正方形 */
            background: #fff;
            border: 1px solid #e0e0e0;
            transition: all 0.15s ease;
            position: relative;
        }
        
        .cell.filled {
            background: #3498db;
            border: 1px solid #2980b9;
            box-shadow: inset 2px 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        /* 添加方块移动和旋转动画 */
        .cell.new-piece {
            animation: popIn 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        
        .cell.moving {
            animation: movePiece 0.1s ease-out;
        }
        
        .cell.rotating {
            animation: rotatePiece 0.2s ease-out;
        }
        
        @keyframes movePiece {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        @keyframes rotatePiece {
            0% { transform: rotate(0deg) scale(1); }
            50% { transform: rotate(90deg) scale(1.1); }
            100% { transform: rotate(180deg) scale(1); }
        }
        
        .controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            width: 100%;
            flex-shrink: 0;
            animation: slideIn 0.5s ease-out 0.2s both;
        }
        
        .buttons {
            display: flex;
            gap: 6px;
            width: 100%;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        button {
            padding: 8px 10px;
            font-size: 0.8rem;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s ease;
            flex: 1;
            min-width: 65px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        button:hover {
            background: #2980b9;
            transform: translateY(-1px);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        }
        
        button:active {
            transform: translateY(0);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }
        
        .back-home {
            position: absolute;
            top: 10px;
            left: 10px;
            background: #34495e;
            color: white;
            border: none;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            z-index: 20;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
            text-decoration: none;
        }
        
        .back-home:hover {
            background: #2c3e50;
            transform: scale(1.15) rotate(-10deg);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        .back-home:active {
            transform: scale(1.05);
        }
        
        /* 游戏结束提示 */
        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.8);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 16px;
            border-radius: 10px;
            text-align: center;
            z-index: 100;
            display: none;
            opacity: 0;
            transition: all 0.3s ease;
        }
        
        .game-over.show {
            display: block;
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
        }
        
        .game-over h2 {
            margin-bottom: 8px;
            font-size: 1.3rem;
            animation: textPop 0.5s ease-out 0.2s both;
        }
        
        .game-over p {
            margin-bottom: 12px;
            font-size: 1.1rem;
            animation: textPop 0.5s ease-out 0.3s both;
        }
        
        /* 行消除动画 */
        .cell.clearing {
            animation: clearRowAnimation 0.3s ease-out forwards;
        }
        
        .cell.clearing-horizontal {
            animation: clearRowAnimationHorizontal 0.3s ease-out forwards;
        }
        
        .cell.clearing-vertical {
            animation: clearRowAnimationVertical 0.3s ease-out forwards;
        }
        
        /* 动画定义 */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        @keyframes slideIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        @keyframes popIn {
            0% { transform: scale(0.5); opacity: 0; }
            70% { transform: scale(1.1); opacity: 1; }
            100% { transform: scale(1); }
        }
        
        @keyframes clearRowAnimation {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.7; }
            100% { transform: scale(0); opacity: 0; }
        }
        
        @keyframes clearRowAnimationHorizontal {
            0% { transform: scaleX(1); opacity: 1; }
            100% { transform: scaleX(0); opacity: 0; }
        }
        
        @keyframes clearRowAnimationVertical {
            0% { transform: scaleY(1); opacity: 1; }
            100% { transform: scaleY(0); opacity: 0; }
        }
        
        @keyframes textPop {
            0% { transform: scale(0.8); opacity: 0; }
            70% { transform: scale(1.1); opacity: 1; }
            100% { transform: scale(1); }
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        @keyframes glow {
            0% { box-shadow: 0 0 5px rgba(52, 152, 219, 0.5); }
            50% { box-shadow: 0 0 15px rgba(52, 152, 219, 0.8); }
            100% { box-shadow: 0 0 5px rgba(52, 152, 219, 0.5); }
        }
        
        .cell.current-piece {
            animation: glow 1.5s infinite;
        }
        
        /* 平板设备优化 */
        @media (min-width: 481px) and (max-width: 768px) {
            .game-container {
                max-width: 400px;
                max-height: 650px;
            }
            
            .game-board {
                height: 450px;
            }
            
            h1 {
                font-size: 1.5rem;
            }
            
            .stat-box .value {
                font-size: 1.1rem;
            }
            
            button {
                padding: 9px 12px;
                font-size: 0.85rem;
                min-width: 70px;
            }
        }
        
        /* 移动端优化 */
        @media (max-width: 480px) {
            .game-container {
                padding: 10px;
                height: 100vh;
                max-height: 100vh;
                border-radius: 0;
                padding-top: 50px; /* 为返回按钮留出空间 */
            }
            
            .game-board {
                height: 350px;
            }
            
            h1 {
                font-size: 1.3rem;
                margin: 5px 0 8px;
            }
            
            .stats {
                flex-wrap: wrap;
                gap: 5px;
            }
            
            .stat-box {
                flex: 1 1 45%;
            }
            
            .stat-box .label {
                font-size: 0.7rem;
            }
            
            .stat-box .value {
                font-size: 0.9rem;
            }
            
            .difficulty-selector {
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 5px;
            }
            
            .difficulty-selector label {
                margin-right: 0;
            }
            
            .difficulty-selector select {
                width: 100%;
                max-width: 200px;
            }
            
            button {
                padding: 7px 8px;
                font-size: 0.75rem;
                min-width: 60px;
            }
            
            .buttons {
                flex-wrap: wrap;
            }
            
            .buttons button {
                flex: 1 1 45%;
                margin-bottom: 5px;
            }
        }
        
        /* 桌面设备优化 */
        @media (min-width: 769px) {
            .game-container {
                max-width: 450px;
                max-height: 700px;
            }
            
            .game-board {
                height: 500px;
            }
            
            h1 {
                font-size: 1.8rem;
            }
            
            .stat-box .value {
                font-size: 1.2rem;
            }
            
            button {
                padding: 10px 15px;
                font-size: 0.9rem;
                min-width: 80px;
            }
        }
        
        /* 教程模态框样式 */
        .tutorial-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }
        
        .tutorial-modal.active {
            opacity: 1;
            visibility: visible;
        }
        
        .tutorial-content {
            background: white;
            border-radius: 12px;
            width: 90%;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            transform: scale(0.9);
            transition: transform 0.3s ease;
        }
        
        .tutorial-modal.active .tutorial-content {
            transform: scale(1);
        }
        
        .tutorial-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            border-bottom: 2px solid #3498db;
            background: #f8f9fa;
            border-radius: 12px 12px 0 0;
        }
        
        .tutorial-header h2 {
            color: #2c3e50;
            margin: 0;
            font-size: 1.5rem;
            font-weight: bold;
        }
        
        .tutorial-close {
            background: #f8f9fa;
            border: 2px solid #e0e0e0;
            font-size: 1.5rem;
            font-weight: bold;
            color: #2c3e50;
            cursor: pointer;
            padding: 0;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .tutorial-close:hover {
            background: #e74c3c;
            color: white;
            border-color: #e74c3c;
            transform: scale(1.1);
            box-shadow: 0 4px 8px rgba(231, 76, 60, 0.3);
        }
        
        .tutorial-close:active {
            transform: scale(0.95);
            box-shadow: 0 2px 4px rgba(231, 76, 60, 0.2);
        }
        
        .tutorial-body {
            padding: 20px;
            color: #2c3e50;
        }
        
        .tutorial-section {
            margin-bottom: 20px;
        }
        
        .tutorial-section h3 {
            color: #3498db;
            margin: 0 0 10px 0;
            font-size: 1.1rem;
            font-weight: bold;
            border-bottom: 1px solid #ecf0f1;
            padding-bottom: 5px;
        }
        
        .tutorial-section p {
            margin: 0 0 10px 0;
            line-height: 1.5;
        }
        
        .tutorial-section ul {
            margin: 0 0 10px 0;
            padding-left: 20px;
        }
        
        .tutorial-section li {
            margin-bottom: 5px;
            line-height: 1.4;
        }
        
        /* 移动端教程模态框优化 */
        @media (max-width: 480px) {
            .tutorial-content {
                width: 95%;
                max-height: 90vh;
            }
            
            .tutorial-header {
                padding: 15px;
            }
            
            .tutorial-header h2 {
                font-size: 1.3rem;
            }
            
            .tutorial-body {
                padding: 15px;
            }
            
            .tutorial-section h3 {
                font-size: 1rem;
            }
        }
    </style>
</head>
<body>
    <a class="back-home" href="../index.html">←</a>
    <div class="game-container">
        <h1>俄罗斯方块</h1>
        <div class="stats">
            <div class="stat-box">
                <div class="label">得分</div>
                <div class="value" id="score">0</div>
            </div>
            <div class="stat-box">
                <div class="label">最高分</div>
                <div class="value" id="high-score">0</div>
            </div>
            <div class="stat-box">
                <div class="label">等级</div>
                <div class="value" id="level">1</div>
            </div>
            <div class="stat-box">
                <div class="label">行数</div>
                <div class="value" id="lines">0</div>
            </div>
            <div class="stat-box" id="ai-status" style="display: none;">
                <div class="label">AI状态</div>
                <div class="value" style="color: #e74c3c; font-weight: bold;">启用</div>
            </div>
        </div>
        <div class="game-board" id="board"></div>
        <div class="controls">
            <div class="difficulty-selector" style="margin-bottom: 15px; width: 100%; max-width: 300px;">
                <div style="text-align: center; margin-bottom: 8px; font-weight: 500; color: #2c3e50;">难度选择</div>
                <div style="display: flex; gap: 8px; justify-content: center;">
                    <button class="difficulty-btn" data-difficulty="easy" style="flex: 1; padding: 8px 12px; border: 2px solid #ddd; border-radius: 8px; background: #f8f9fa; color: #2c3e50; font-weight: 500; transition: all 0.2s ease;">初级</button>
                    <button class="difficulty-btn active" data-difficulty="medium" style="flex: 1; padding: 8px 12px; border: 2px solid #3498db; border-radius: 8px; background: #3498db; color: white; font-weight: 500; transition: all 0.2s ease;">中级</button>
                    <button class="difficulty-btn" data-difficulty="hard" style="flex: 1; padding: 8px 12px; border: 2px solid #ddd; border-radius: 8px; background: #f8f9fa; color: #2c3e50; font-weight: 500; transition: all 0.2s ease;">高级</button>
                </div>
                <input type="hidden" id="difficultySelect" value="medium">
            </div>
            <div class="buttons">
                <button id="startBtn">开始</button>
                <button id="pauseBtn">暂停</button>
                <button id="resetBtn">重置</button>
                <button id="tutorial-btn">玩法教程</button>
                <button id="ai-toggle" style="display: none; padding: 8px 12px; background: #e74c3c; color: white; border: none; border-radius: 6px; font-weight: 500; transition: all 0.2s ease;">关闭AI</button>
            </div>
            
            <!-- 移动端虚拟方向键 -->
            <div class="virtual-controls" style="display: none; margin-top: 15px; width: 100%; max-width: 250px;">
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-bottom: 8px;">
                    <div></div>
                    <button class="control-btn" data-action="rotate" style="grid-column: 2; padding: 10px; background: #3498db; color: white; border: none; border-radius: 8px; font-size: 1.2rem;">↑</button>
                    <div></div>
                </div>
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px;">
                    <button class="control-btn" data-action="left" style="padding: 10px; background: #3498db; color: white; border: none; border-radius: 8px; font-size: 1.2rem;">←</button>
                    <button class="control-btn" data-action="down" style="padding: 10px; background: #3498db; color: white; border: none; border-radius: 8px; font-size: 1.2rem;">↓</button>
                    <button class="control-btn" data-action="right" style="padding: 10px; background: #3498db; color: white; border: none; border-radius: 8px; font-size: 1.2rem;">→</button>
                </div>
                <div style="margin-top: 8px;">
                    <button class="control-btn" data-action="hardDrop" style="width: 100%; padding: 10px; background: #e74c3c; color: white; border: none; border-radius: 8px; font-size: 0.9rem;">快速下落</button>
                </div>
            </div>
        </div>
        <div class="game-over" id="game-over">
            <h2>游戏结束</h2>
            <p>得分: <span id="final-score">0</span></p>
            <button id="play-again">再玩一次</button>
        </div>
    </div>

    <!-- 教程模态框 -->
    <div id="tutorial-modal" class="tutorial-modal">
        <div class="tutorial-content">
            <div class="tutorial-header">
                <h2>玩法教程</h2>
                <button class="tutorial-close">×</button>
            </div>
            <div class="tutorial-body">
                <div class="tutorial-section">
                    <h3>游戏目标</h3>
                    <p>通过移动和旋转下落的方块，填满一行消除得分，挑战更高分数！</p>
                </div>
                <div class="tutorial-section">
                    <h3>操作方法</h3>
                    <ul>
                        <li>键盘：使用方向键控制方块移动</li>
                        <li>↑ 键：旋转方块</li>
                        <li>↓ 键：加速下落</li>
                        <li>←→ 键：左右移动方块</li>
                        <li>空格：直接下落到底部</li>
                        <li>触摸：在屏幕上滑动手指控制方块</li>
                    </ul>
                </div>
                <div class="tutorial-section">
                    <h3>游戏规则</h3>
                    <ul>
                        <li>方块会从顶部随机生成并自动下落</li>
                        <li>填满一整行方块会消除该行并得分</li>
                        <li>方块堆积到顶部时游戏结束</li>
                        <li>每消除5行升级一次，等级越高方块下落速度越快</li>
                    </ul>
                </div>
                <div class="tutorial-section">
                    <h3>得分机制</h3>
                    <ul>
                        <li>消除1行：100分 × 当前等级</li>
                        <li>消除2行：300分 × 当前等级</li>
                        <li>消除3行：500分 × 当前等级</li>
                        <li>消除4行：800分 × 当前等级</li>
                    </ul>
                </div>
                <div class="tutorial-section">
                    <h3>技巧提示</h3>
                    <ul>
                        <li>尽量保持底部平整，避免出现孔洞</li>
                        <li>优先消除多行以获得更高分数</li>
                        <li>合理使用旋转功能调整方块位置</li>
                        <li>在合适时机使用硬下降（空格）节省时间</li>
                        <li>注意观察下一个方块，提前规划放置位置</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
    
    <!-- 困难模式确认模态框 -->
    <div id="difficulty-confirm-modal" class="tutorial-modal">
        <div class="tutorial-content" style="max-width: 400px;">
            <div class="tutorial-header">
                <h2>难度确认</h2>
                <button class="tutorial-close">×</button>
            </div>
            <div class="tutorial-body" style="text-align: center;">
                <div style="font-size: 1.1rem; margin-bottom: 20px;">当前难度过高，是否确认选择？</div>
                <div style="display: flex; gap: 15px; justify-content: center;">
                    <button id="difficulty-confirm-yes" style="padding: 10px 20px; background: #3498db; color: white; border: none; border-radius: 6px; font-size: 1rem; font-weight: 500; cursor: pointer; transition: all 0.2s ease;">确认</button>
                    <button id="difficulty-confirm-no" style="padding: 10px 20px; background: #e74c3c; color: white; border: none; border-radius: 6px; font-size: 1rem; font-weight: 500; cursor: pointer; transition: all 0.2s ease;">取消</button>
                </div>
            </div>
        </div>
    </div>

    <script src="../js/lib/hammer.min.js"></script>
    <script src="../js/logger.js"></script>
    <script src="../js/dataManager.js"></script>
    <script src="../js/scoreManager.js"></script>
    <script>
        // 俄罗斯方块核心游戏逻辑
        document.addEventListener('DOMContentLoaded', () => {
            // ==========================================
            // 游戏常量和状态
            // ==========================================
            
            // 游戏网格尺寸 - 标准10列×20行
            const COLS = 10;
            const ROWS = 20;
            
            // 游戏状态变量
            let board = [];           // 游戏板数据
            let score = 0;            // 当前得分
            let highScore = 0;        // 最高分
            let level = 1;            // 当前等级
            let lines = 0;            // 已消除行数
            let gameOver = false;     // 游戏是否结束
            let isPaused = false;      // 游戏是否暂停
            let gameInterval;          // 游戏循环ID
            let dropCounter = 0;       // 下落计数器
            let currentDifficulty = 'medium'; // 当前难度级别
            
            // AI相关状态变量
            let isAIEnabled = false;   // AI是否启用
            let aiSpeedMultiplier = 1.2; // AI模式下的速度倍数
            let aiLinesCleared = 0;    // AI模式下已消除的行数
            let aiSpeedIncrement = 0;  // AI模式下的速度增量
            
            // 难度配置 - 不同级别对应不同的下落速度参数
            const difficultySettings = {
                easy: {
                    initialDropInterval: 800, // 初始下落间隔（毫秒）
                    minDropInterval: 200,    // 最小下落间隔（毫秒）
                    speedIncrease: 30        // 每级速度增加（毫秒）
                },
                medium: {
                    initialDropInterval: 600, // 初始下落间隔（毫秒）
                    minDropInterval: 150,    // 最小下落间隔（毫秒）
                    speedIncrease: 40        // 每级速度增加（毫秒）
                },
                hard: {
                    initialDropInterval: 400, // 初始下落间隔（毫秒）
                    minDropInterval: 100,    // 最小下落间隔（毫秒）
                    speedIncrease: 50        // 每级速度增加（毫秒）
                }
            };
            
            // 异步加载高分
            scoreManager.getHighScore('tetris', 0).then(loadedHighScore => {
                highScore = loadedHighScore;
                document.getElementById('high-score').textContent = highScore;
            });            
            // 当前方块
            let currentPiece = {
                shape: [],
                x: 0,
                y: 0,
                color: ''
            };
            
            // 方块类型 - 使用更现代的颜色方案
            const SHAPES = [
                { shape: [[1, 1, 1, 1]], color: '#00f0ff' }, // I - 青色
                { shape: [[1, 1], [1, 1]], color: '#ffeb3b' }, // O - 黄色
                { shape: [[0, 1, 0], [1, 1, 1]], color: '#9c27b0' }, // T - 紫色
                { shape: [[1, 1, 0], [0, 1, 1]], color: '#4caf50' }, // S - 绿色
                { shape: [[0, 1, 1], [1, 1, 0]], color: '#f44336' }, // Z - 红色
                { shape: [[1, 0, 0], [1, 1, 1]], color: '#ff9800' }, // J - 橙色
                { shape: [[0, 0, 1], [1, 1, 1]], color: '#2196f3' }  // L - 蓝色
            ];
            
            // 初始化游戏板
            function initBoard() {
                board = Array.from({ length: ROWS }, () => 
                    Array.from({ length: COLS }, () => ({ filled: false, color: '#fff' }))
                );
            }
            
            // 创建新方块
            function createNewPiece() {
                const randomIndex = Math.floor(Math.random() * SHAPES.length);
                const shape = SHAPES[randomIndex].shape;
                const color = SHAPES[randomIndex].color;
                
                return {
                    shape: shape,
                    x: Math.floor(COLS / 2) - Math.floor(shape[0].length / 2),
                    y: 0,
                    color: color
                };
            }
            
            // 检查方块是否与现有块或边界碰撞
            function isCollision(piece, dx = 0, dy = 0) {
                for (let y = 0; y < piece.shape.length; y++) {
                    for (let x = 0; x < piece.shape[y].length; x++) {
                        if (piece.shape[y][x]) {
                            const newX = piece.x + x + dx;
                            const newY = piece.y + y + dy;
                            
                            if (
                                newX < 0 || 
                                newX >= COLS || 
                                newY >= ROWS || 
                                (newY >= 0 && board[newY][newX].filled)
                            ) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }
            
            // 将方块固定在游戏板上
            function mergePieceToBoard() {
                for (let y = 0; y < currentPiece.shape.length; y++) {
                    for (let x = 0; x < currentPiece.shape[y].length; x++) {
                        if (currentPiece.shape[y][x]) {
                            const boardY = currentPiece.y + y;
                            const boardX = currentPiece.x + x;
                            
                            if (boardY >= 0) { // 只有在可见区域内才设置
                                board[boardY][boardX] = { 
                                    filled: true, 
                                    color: currentPiece.color 
                                };
                            }
                        }
                    }
                }
            }
            
            // 检查并清除完整的行（带动画效果）
            function clearLines() {
                let linesCleared = 0;
                const linesToClear = [];
                
                for (let y = ROWS - 1; y >= 0; y--) {
                    if (board[y].every(cell => cell.filled)) {
                        linesToClear.push(y);
                    }
                }
                
                if (linesToClear.length > 0) {
                    // 为要清除的行中的每个单元格添加动画
                    linesToClear.forEach(lineIndex => {
                        for (let x = 0; x < COLS; x++) {
                            // 计算单元格在DOM中的正确索引
                            // 网格是按行排列的，所以 y * COLS + x
                            const cellIndex = lineIndex * COLS + x;
                            const cellElement = document.querySelector(`#board > div:nth-child(${cellIndex + 1})`);
                            if (cellElement) {
                                // 随机选择一种清除动画效果
                                const animationTypes = ['clearing', 'clearing-horizontal', 'clearing-vertical'];
                                const randomAnimation = animationTypes[Math.floor(Math.random() * animationTypes.length)];
                                cellElement.classList.add(randomAnimation);
                            }
                        }
                    });
                    
                    // 延迟处理行消除，以便显示动画
                    setTimeout(() => {
                        // 实际清除行 - 先更新逻辑board状态
                        linesToClear.forEach(lineIndex => {
                            // 从board数组中移除完整的行（从高索引开始删除，避免索引错位）
                            board.splice(lineIndex, 1);
                            // 在顶部添加新的空行
                            board.unshift(Array.from({ length: COLS }, () => ({ filled: false, color: '#fff' })));
                        });
                        
                        linesCleared = linesToClear.length;
                        
                        // 更新分数
                        const points = [100, 300, 500, 800]; // 1, 2, 3, 4行的分数
                        score += points[Math.min(linesCleared - 1, 3)] * level;
                        lines += linesCleared;
                        
                        // 更新等级（每5行升一级）
                        level = Math.floor(lines / 5) + 1;
                        
                        // AI模式下的速度控制
                        if (isAIEnabled) {
                            aiLinesCleared += linesCleared;
                            
                            // 每消除5行，速度提升15%
                            const newSpeedIncrement = Math.floor(aiLinesCleared / 5);
                            if (newSpeedIncrement > aiSpeedIncrement) {
                                aiSpeedMultiplier *= 1.15; // 速度提升15%
                                aiSpeedIncrement = newSpeedIncrement;
                                console.log(`AI速度提升！当前倍数: ${aiSpeedMultiplier.toFixed(2)}`);
                            }
                        }
                        
                        // 检查是否打破高分记录
                        if (score > highScore) {
                            highScore = score;
                            scoreManager.updateHighScore('tetris', highScore);
                            document.getElementById('high-score').textContent = highScore;
                        }
                        
                        // 更新UI
                        document.getElementById('score').textContent = score;
                        document.getElementById('level').textContent = level;
                        document.getElementById('lines').textContent = lines;
                        
                        // 重新绘制游戏板，但要保留正在播放动画的类
                        drawBoard();
                        
                        // 清除动画类
                        linesToClear.forEach(lineIndex => {
                            for (let x = 0; x < COLS; x++) {
                                const cellIndex = lineIndex * COLS + x;
                                const cellElement = document.querySelector(`#board > div:nth-child(${cellIndex + 1})`);
                                if (cellElement) {
                                    cellElement.classList.remove('clearing', 'clearing-horizontal', 'clearing-vertical');
                                }
                            }
                        });
                        
                    }, 300); // 等待动画完成
                }
                
                return linesCleared;
            }
            
            // 绘制游戏板 - 性能优化版
            function drawBoard() {
                const boardElement = document.getElementById('board');
                
                // 保存当前正在播放动画的单元格的信息
                const animatingCells = new Map(); // 使用Map存储动画类型
                for (let y = 0; y < ROWS; y++) {
                    for (let x = 0; x < COLS; x++) {
                        const cellIndex = y * COLS + x;
                        const cellElement = boardElement.children[cellIndex];
                        if (cellElement) {
                            if (cellElement.classList.contains('clearing')) {
                                animatingCells.set(cellIndex, 'clearing');
                            } else if (cellElement.classList.contains('clearing-horizontal')) {
                                animatingCells.set(cellIndex, 'clearing-horizontal');
                            } else if (cellElement.classList.contains('clearing-vertical')) {
                                animatingCells.set(cellIndex, 'clearing-vertical');
                            }
                        }
                    }
                }
                
                // 优化：仅在必要时重绘整个游戏板
                if (boardElement.children.length !== ROWS * COLS) {
                    // 清空游戏板
                    boardElement.innerHTML = '';
                    
                    // 批量创建单元格元素
                    const fragment = document.createDocumentFragment();
                    
                    // 绘制已固定的方块
                    for (let y = 0; y < ROWS; y++) {
                        for (let x = 0; x < COLS; x++) {
                            const cell = document.createElement('div');
                            cell.className = 'cell';
                            if (board[y][x].filled) {
                                cell.classList.add('filled');
                                cell.style.backgroundColor = board[y][x].color;
                            }
                            fragment.appendChild(cell);
                        }
                    }
                    
                    boardElement.appendChild(fragment);
                } else {
                    // 优化：仅更新需要变化的单元格
                    for (let y = 0; y < ROWS; y++) {
                        for (let x = 0; x < COLS; x++) {
                            const cellIndex = y * COLS + x;
                            const cell = boardElement.children[cellIndex];
                            if (cell) {
                                if (board[y][x].filled) {
                                    if (!cell.classList.contains('filled') || cell.style.backgroundColor !== board[y][x].color) {
                                        cell.classList.add('filled');
                                        cell.style.backgroundColor = board[y][x].color;
                                    }
                                } else {
                                    if (cell.classList.contains('filled')) {
                                        cell.classList.remove('filled');
                                        cell.style.backgroundColor = '';
                                    }
                                }
                            }
                        }
                    }
                }
                
                // 绘制当前方块
                for (let y = 0; y < currentPiece.shape.length; y++) {
                    for (let x = 0; x < currentPiece.shape[y].length; x++) {
                        if (currentPiece.shape[y][x]) {
                            const boardY = currentPiece.y + y;
                            const boardX = currentPiece.x + x;
                            
                            if (boardY >= 0 && boardY < ROWS && boardX >= 0 && boardX < COLS) {
                                const index = boardY * COLS + boardX;
                                const cell = boardElement.children[index];
                                if (cell) {
                                    cell.classList.add('filled', 'new-piece');
                                    cell.style.backgroundColor = currentPiece.color;
                                }
                            }
                        }
                    }
                }
                
                // 恢复动画类到对应的单元格
                animatingCells.forEach((animationType, index) => {
                    const cellElement = boardElement.children[index];
                    if (cellElement) {
                        const row = Math.floor(index / COLS);
                        const col = index % COLS;
                        if (board[row][col].filled) {
                            cellElement.classList.add(animationType);
                        }
                    }
                });
            }
            
            // 旋转方块
            function rotatePiece() {
                if (isPaused || gameOver) return false;
                
                const originalShape = currentPiece.shape;
                
                // 创建旋转后的新形状
                const rows = originalShape.length;
                const cols = originalShape[0].length;
                const newShape = Array.from({ length: cols }, () => Array(rows).fill(0));
                
                for (let y = 0; y < rows; y++) {
                    for (let x = 0; x < cols; x++) {
                        newShape[x][rows - 1 - y] = originalShape[y][x];
                    }
                }
                
                const originalRotation = currentPiece.shape;
                currentPiece.shape = newShape;
                
                // 如果旋转后发生碰撞，则恢复原形状
                if (isCollision(currentPiece)) {
                    currentPiece.shape = originalRotation;
                    return false; // 旋转失败
                }
                
                // 添加旋转动画
                for (let y = 0; y < currentPiece.shape.length; y++) {
                    for (let x = 0; x < currentPiece.shape[y].length; x++) {
                        if (currentPiece.shape[y][x]) {
                            const boardY = currentPiece.y + y;
                            const boardX = currentPiece.x + x;
                            if (boardY >= 0 && boardY < ROWS && boardX >= 0 && boardX < COLS) {
                                const index = boardY * COLS + boardX;
                                const cell = document.querySelector(`#board > div:nth-child(${index + 1})`);
                                if (cell) {
                                    cell.classList.add('rotating');
                                    setTimeout(() => cell.classList.remove('rotating'), 200);
                                }
                            }
                        }
                    }
                }
                
                drawBoard(); // 旋转后立即更新显示
                return true; // 旋转成功
            }
            
            // 移动方块
            function movePiece(dx, dy) {
                if (isPaused || gameOver) return false;
                
                if (!isCollision(currentPiece, dx, dy)) {
                    currentPiece.x += dx;
                    currentPiece.y += dy;
                    
                    // 添加移动动画
                    for (let y = 0; y < currentPiece.shape.length; y++) {
                        for (let x = 0; x < currentPiece.shape[y].length; x++) {
                            if (currentPiece.shape[y][x]) {
                                const boardY = currentPiece.y + y;
                                const boardX = currentPiece.x + x;
                                if (boardY >= 0 && boardY < ROWS && boardX >= 0 && boardX < COLS) {
                                    const index = boardY * COLS + boardX;
                                    const cell = document.querySelector(`#board > div:nth-child(${index + 1})`);
                                    if (cell) {
                                        cell.classList.add('moving');
                                        setTimeout(() => cell.classList.remove('moving'), 100);
                                    }
                                }
                            }
                        }
                    }
                    
                    drawBoard(); // 移动后立即更新显示
                    return true;
                } else if (dy > 0) {
                    // 如果向下移动时碰撞，则固定方块
                    mergePieceToBoard();
                    clearLines();
                    currentPiece = createNewPiece();
                    
                    // 检查游戏结束
                                            if (isCollision(currentPiece)) {
                                                gameOver = true;
                                                if (gameInterval) {
                                                    cancelAnimationFrame(gameInterval);
                                                    gameInterval = null;
                                                }
                                                
                                                // 记录游戏结果
                                                scoreManager.recordGameResult('tetris', 'loss', score);
                                                
                                                // 显示游戏结束界面
                                                document.getElementById('final-score').textContent = score;
                                                const gameOverElement = document.getElementById('game-over');
                                                gameOverElement.classList.add('show');
                                                return false;
                                            }
                    drawBoard(); // 更新显示
                    return false;
                }
                
                return false;
            }
                
            // 硬下降（直接下降到最底部）
            function hardDrop() {
                if (isPaused || gameOver) return;
                
                let dropDistance = 0;
                while (movePiece(0, 1)) {
                    dropDistance++;
                }
                
                // 只在需要时绘制一次
                drawBoard();
            }
            
            // 游戏主循环 - 性能优化版
            function gameLoop(timestamp) {
                if (gameOver) {
                    if (gameInterval) {
                        cancelAnimationFrame(gameInterval);
                        gameInterval = null;
                    }
                    return;
                }
                
                if (!isPaused) {
                    // 优化：缓存难度设置，避免重复查找
                    const difficulty = difficultySettings[currentDifficulty];
                    
                    // 计算基础下落速度
                    let baseDropInterval = Math.max(
                        difficulty.minDropInterval,
                        difficulty.initialDropInterval - (level - 1) * difficulty.speedIncrease
                    );
                    
                    // AI模式下的速度调整
                    if (isAIEnabled) {
                        // 计算AI模式下的速度
                        let aiDropInterval = baseDropInterval / aiSpeedMultiplier;
                        
                        // 确保速度不会过快
                        aiDropInterval = Math.max(difficulty.minDropInterval * 0.8, aiDropInterval);
                        
                        // 优化：仅在等级或速度变化时重新计算下落速度
                        if (!window.lastLevel || window.lastLevel !== level || window.lastDifficulty !== currentDifficulty || window.lastAiSpeedMultiplier !== aiSpeedMultiplier) {
                            window.currentDropInterval = aiDropInterval;
                            window.lastLevel = level;
                            window.lastDifficulty = currentDifficulty;
                            window.lastAiSpeedMultiplier = aiSpeedMultiplier;
                        }
                    } else {
                        // 普通模式
                        // 优化：仅在等级变化时重新计算下落速度
                        if (!window.lastLevel || window.lastLevel !== level || window.lastDifficulty !== currentDifficulty) {
                            window.currentDropInterval = baseDropInterval;
                            window.lastLevel = level;
                            window.lastDifficulty = currentDifficulty;
                        }
                    }
                    
                    // 计算时间差
                    const now = timestamp;
                    if (!dropCounter) dropCounter = now;
                    const delta = now - dropCounter;
                    
                    // 根据等级调整下落速度
                    if (delta > window.currentDropInterval) {
                        movePiece(0, 1);
                        dropCounter = now;
                    }
                }
                
                gameInterval = requestAnimationFrame(gameLoop);
            }
            
            // 开始/暂停游戏
            function togglePause() {
                if (gameOver) return;
                
                isPaused = !isPaused;
                document.getElementById('pauseBtn').textContent = isPaused ? '继续' : '暂停';
            }
            
            // 开始游戏
            function startGame() {
                if (gameOver) {
                    resetGame();
                    return;
                }
                
                if (!gameInterval) {
                    gameInterval = requestAnimationFrame(gameLoop);
                    document.getElementById('startBtn').textContent = '重新开始';
                } else {
                    resetGame();
                }
            }
            
            // 重置游戏
            function resetGame() {
                if (gameInterval) {
                    cancelAnimationFrame(gameInterval);
                    gameInterval = null;
                }
                
                initBoard();
                score = 0;
                level = 1;
                lines = 0;
                gameOver = false;
                isPaused = false;
                dropCounter = 0;
                
                document.getElementById('score').textContent = score;
                document.getElementById('level').textContent = level;
                document.getElementById('lines').textContent = lines;
                document.getElementById('startBtn').textContent = '开始';
                document.getElementById('pauseBtn').textContent = '暂停';
                
                // 隐藏游戏结束界面
                document.getElementById('game-over').classList.remove('show');
                
                currentPiece = createNewPiece();
                drawBoard();
                gameInterval = requestAnimationFrame(gameLoop);
            }
            
            // 键盘事件处理
            document.addEventListener('keydown', (e) => {
                if (gameOver) return;
                
                switch (e.key) {
                    case 'ArrowLeft':
                        movePiece(-1, 0);
                        e.preventDefault();
                        break;
                    case 'ArrowRight':
                        movePiece(1, 0);
                        e.preventDefault();
                        break;
                    case 'ArrowDown':
                        movePiece(0, 1);
                        e.preventDefault();
                        break;
                    case 'ArrowUp':
                        rotatePiece();
                        e.preventDefault();
                        break;
                    case ' ':
                        hardDrop();
                        e.preventDefault();
                        break;
                    case 'p':
                    case 'P':
                        togglePause();
                        e.preventDefault();
                        break;
                }
            });
            
            // 初始化hammer.js手势控制器
            const gameBoardElement = document.getElementById('board');
            let hammerManager = null;
            
            // 修复手势控制器，确保在正确的时间初始化
            setTimeout(() => {
                hammerManager = new Hammer.Manager(gameBoardElement);
                hammerManager.add(new Hammer.Swipe({ 
                    direction: Hammer.DIRECTION_ALL, 
                    threshold: 10, // 降低阈值，提高灵敏度
                    velocity: 0.2 // 降低速度要求，提高灵敏度
                }));
                
                // 添加Tap事件支持
                hammerManager.add(new Hammer.Tap({ event: 'doubletap', taps: 2 }));
                
                hammerManager.on('swipeleft', (e) => {
                    if (!isPaused && !gameOver) {
                        movePiece(-1, 0);
                    }
                    e.preventDefault();
                });
                
                hammerManager.on('swiperight', (e) => {
                    if (!isPaused && !gameOver) {
                        movePiece(1, 0);
                    }
                    e.preventDefault();
                });
                
                hammerManager.on('swipeup', (e) => {
                    if (!isPaused && !gameOver) {
                        rotatePiece();
                    }
                    e.preventDefault();
                });
                
                hammerManager.on('swipedown', (e) => {
                    if (!isPaused && !gameOver) {
                        movePiece(0, 1);
                    }
                    e.preventDefault();
                });
                
                // 添加双击事件处理（快速下落）
                hammerManager.on('doubletap', (e) => {
                    if (!isPaused && !gameOver) {
                        hardDrop();
                    }
                    e.preventDefault();
                });
                
                // 保存控制器实例以便在游戏状态变化时能访问
                window.hammerManager = hammerManager;
            }, 100); // 延迟初始化，确保DOM完全加载
            
            // 按钮事件处理
            document.getElementById('startBtn').addEventListener('click', startGame);
            document.getElementById('pauseBtn').addEventListener('click', togglePause);
            document.getElementById('resetBtn').addEventListener('click', resetGame);
            document.getElementById('play-again').addEventListener('click', () => {
                document.getElementById('game-over').classList.remove('show');
                resetGame();
            });
            
            // 困难模式确认模态框
            const difficultyConfirmModal = document.getElementById('difficulty-confirm-modal');
            const difficultyConfirmYes = document.getElementById('difficulty-confirm-yes');
            const difficultyConfirmNo = document.getElementById('difficulty-confirm-no');
            let pendingDifficulty = null;
            
            // 显示困难模式确认模态框
            function showDifficultyConfirmModal(difficulty) {
                pendingDifficulty = difficulty;
                difficultyConfirmModal.classList.add('active');
            }
            
            // 隐藏困难模式确认模态框
            function hideDifficultyConfirmModal() {
                pendingDifficulty = null;
                difficultyConfirmModal.classList.remove('active');
            }
            
            // 难度选择按钮事件处理
            const difficultyBtns = document.querySelectorAll('.difficulty-btn');
            const difficultySelect = document.getElementById('difficultySelect');
            
            difficultyBtns.forEach(btn => {
                btn.addEventListener('click', function() {
                    const newDifficulty = this.getAttribute('data-difficulty');
                    
                    // 如果选择困难模式，显示确认模态框
                    if (newDifficulty === 'hard') {
                        showDifficultyConfirmModal(newDifficulty);
                        return;
                    }
                    
                    // 非困难模式直接更新
                    updateDifficulty(newDifficulty, this);
                });
            });
            
            // 更新难度函数
            function updateDifficulty(newDifficulty, activeBtn) {
                // 更新按钮状态
                difficultyBtns.forEach(b => {
                    b.classList.remove('active');
                    b.style.borderColor = '#ddd';
                    b.style.background = '#f8f9fa';
                    b.style.color = '#2c3e50';
                });
                activeBtn.classList.add('active');
                activeBtn.style.borderColor = '#3498db';
                activeBtn.style.background = '#3498db';
                activeBtn.style.color = 'white';
                
                // 更新隐藏输入值
                difficultySelect.value = newDifficulty;
                
                // 更新当前难度
                const oldDifficulty = currentDifficulty;
                currentDifficulty = newDifficulty;
                console.log(`难度已更改为: ${currentDifficulty}`);
                
                // 如果游戏未开始，不需要重置
                if (gameOver || !gameInterval) {
                    return;
                }
                
                // 如果游戏正在进行，询问是否重置游戏以应用新难度
                if (!isPaused && !gameOver) {
                    const shouldReset = confirm('更改难度将重置游戏，是否继续？');
                    if (shouldReset) {
                        resetGame();
                    } else {
                        // 恢复原来的难度选择
                        currentDifficulty = oldDifficulty;
                        difficultySelect.value = oldDifficulty;
                        
                        // 恢复按钮状态
                        difficultyBtns.forEach(b => {
                            if (b.getAttribute('data-difficulty') === oldDifficulty) {
                                b.classList.add('active');
                                b.style.borderColor = '#3498db';
                                b.style.background = '#3498db';
                                b.style.color = 'white';
                            } else {
                                b.classList.remove('active');
                                b.style.borderColor = '#ddd';
                                b.style.background = '#f8f9fa';
                                b.style.color = '#2c3e50';
                            }
                        });
                    }
                }
            }
            
            // 困难模式确认按钮事件处理
            if (difficultyConfirmYes) {
                difficultyConfirmYes.addEventListener('click', function() {
                    if (pendingDifficulty === 'hard') {
                        // 找到困难模式按钮
                        const hardBtn = document.querySelector('[data-difficulty="hard"]');
                        if (hardBtn) {
                            updateDifficulty(pendingDifficulty, hardBtn);
                            // 启用AI功能
                            enableAI();
                        }
                    }
                    hideDifficultyConfirmModal();
                });
            }
            
            if (difficultyConfirmNo) {
                difficultyConfirmNo.addEventListener('click', function() {
                    hideDifficultyConfirmModal();
                });
            }
            
            // 关闭按钮事件处理
            const modalCloseBtns = document.querySelectorAll('#difficulty-confirm-modal .tutorial-close');
            modalCloseBtns.forEach(btn => {
                btn.addEventListener('click', hideDifficultyConfirmModal);
            });
            
            // 点击模态框外部关闭
            if (difficultyConfirmModal) {
                difficultyConfirmModal.addEventListener('click', function(e) {
                    if (e.target === this) {
                        hideDifficultyConfirmModal();
                    }
                });
            }
            
            // 重写返回主页按钮的逻辑，添加提交分数选项
            const backHomeButton = document.querySelector('.back-home');
            if (backHomeButton) {
                backHomeButton.addEventListener('click', function(e) {
                    e.preventDefault();
                    
                    // 如果游戏正在进行中，询问是否保存分数
                    if (!gameOver && score > 0) {
                        const shouldSave = confirm(`当前得分: ${score}\n是否将当前分数添加到排行榜？`);
                        if (shouldSave) {
                            // 跳转到主页并带上分数和游戏类型参数
                            window.location.href = `../index.html?score=${score}&game=tetris`;
                        } else {
                            // 直接返回主页
                            window.location.href = `../index.html`;
                        }
                    } else if (gameOver) {
                        // 游戏结束时，询问是否提交最终分数
                        const shouldSave = confirm(`游戏结束！最终得分: ${score}\n是否将此分数添加到排行榜？`);
                        if (shouldSave) {
                            window.location.href = `../index.html?score=${score}&game=tetris`;
                        } else {
                            window.location.href = `../index.html`;
                        }
                    } else {
                        // 如果没有分数，直接返回主页
                        window.location.href = `../index.html`;
                    }
                });
            }
            
            // 检测设备类型并显示/隐藏虚拟方向键
            function checkDeviceType() {
                const virtualControls = document.querySelector('.virtual-controls');
                if (virtualControls) {
                    if (window.innerWidth <= 480 || ('ontouchstart' in window)) {
                        // 移动端或触摸设备
                        virtualControls.style.display = 'block';
                    } else {
                        // 桌面设备
                        virtualControls.style.display = 'none';
                    }
                }
            }
            
            // 为虚拟方向键添加事件监听器
            function initVirtualControls() {
                const controlButtons = document.querySelectorAll('.control-btn');
                controlButtons.forEach(button => {
                    button.addEventListener('click', function() {
                        const action = this.getAttribute('data-action');
                        if (gameOver || isPaused) return;
                        
                        switch (action) {
                            case 'left':
                                movePiece(-1, 0);
                                break;
                            case 'right':
                                movePiece(1, 0);
                                break;
                            case 'down':
                                movePiece(0, 1);
                                break;
                            case 'rotate':
                                rotatePiece();
                                break;
                            case 'hardDrop':
                                hardDrop();
                                break;
                        }
                    });
                });
            }
            
            // 初始化游戏
            initBoard();
            currentPiece = createNewPiece();
            
            // 窗口大小改变时重新检查设备类型
            window.addEventListener('resize', function() {
                checkDeviceType();
            });
            
            drawBoard();
            
            // 初始化虚拟方向键
            checkDeviceType();
            initVirtualControls();
            
            // AI功能相关函数
            function enableAI() {
                isAIEnabled = true;
                aiLinesCleared = 0;
                aiSpeedMultiplier = 1.2;
                aiSpeedIncrement = 0;
                
                // 显示AI状态
                const aiStatus = document.getElementById('ai-status');
                if (aiStatus) {
                    aiStatus.style.display = 'block';
                }
                
                // 显示AI切换按钮
                const aiToggle = document.getElementById('ai-toggle');
                if (aiToggle) {
                    aiToggle.style.display = 'block';
                    aiToggle.textContent = '关闭AI';
                }
                
                // 记录AI启用
                console.log('AI功能已启用');
            }
            
            function disableAI() {
                isAIEnabled = false;
                
                // 隐藏AI状态
                const aiStatus = document.getElementById('ai-status');
                if (aiStatus) {
                    aiStatus.style.display = 'none';
                }
                
                // 隐藏AI切换按钮
                const aiToggle = document.getElementById('ai-toggle');
                if (aiToggle) {
                    aiToggle.style.display = 'none';
                }
                
                // 记录AI禁用
                console.log('AI功能已禁用');
            }
            
            // 分析当前棋盘状态
            function analyzeBoardState() {
                // 计算每行的高度
                const rowHeights = Array(COLS).fill(0);
                for (let x = 0; x < COLS; x++) {
                    for (let y = 0; y < ROWS; y++) {
                        if (board[y][x].filled) {
                            rowHeights[x] = ROWS - y;
                            break;
                        }
                    }
                }
                
                // 计算孔洞数量
                let holes = 0;
                for (let x = 0; x < COLS; x++) {
                    let foundBlock = false;
                    for (let y = 0; y < ROWS; y++) {
                        if (board[y][x].filled) {
                            foundBlock = true;
                        } else if (foundBlock) {
                            holes++;
                        }
                    }
                }
                
                // 计算行的平整度
                let roughness = 0;
                for (let x = 1; x < COLS; x++) {
                    roughness += Math.abs(rowHeights[x] - rowHeights[x-1]);
                }
                
                return {
                    rowHeights,
                    holes,
                    roughness
                };
            }
            
            // 计算玩家最可能需要的方块形状
            function getBestPieceForPlayer() {
                const boardState = analyzeBoardState();
                const { rowHeights, holes, roughness } = boardState;
                
                // 基于棋盘状态评估每种方块的适用性
                const pieceScores = SHAPES.map((shape, index) => {
                    let score = 0;
                    
                    // 根据孔洞数量偏好不同形状
                    if (holes > 5) {
                        // 有很多孔洞，偏好I型方块
                        if (index === 0) score += 10;
                    }
                    
                    // 根据平整度偏好不同形状
                    if (roughness > 15) {
                        // 棋盘不平整，偏好O型方块
                        if (index === 1) score += 10;
                    }
                    
                    // 根据行高度偏好不同形状
                    const averageHeight = rowHeights.reduce((sum, h) => sum + h, 0) / COLS;
                    if (averageHeight > 10) {
                        // 棋盘较高，偏好T型方块
                        if (index === 2) score += 10;
                    }
                    
                    return { index, score };
                });
                
                // 按分数排序，返回得分最高的方块
                pieceScores.sort((a, b) => b.score - a.score);
                return pieceScores[0].index;
            }
            
            // 获取对玩家最不利的方块
            function getWorstPieceForPlayer() {
                const boardState = analyzeBoardState();
                const { rowHeights, holes, roughness } = boardState;
                
                // 基于棋盘状态评估每种方块的不利程度
                const pieceScores = SHAPES.map((shape, index) => {
                    let score = 0;
                    
                    // 根据孔洞数量评估方块的不利程度
                    if (holes > 5) {
                        // 有很多孔洞，I型方块最有利，其他方块相对不利
                        if (index !== 0) score += 10;
                    }
                    
                    // 根据平整度评估方块的不利程度
                    if (roughness > 15) {
                        // 棋盘不平整，O型方块最有利，其他方块相对不利
                        if (index !== 1) score += 10;
                    }
                    
                    // 根据行高度评估方块的不利程度
                    const averageHeight = rowHeights.reduce((sum, h) => sum + h, 0) / COLS;
                    if (averageHeight > 10) {
                        // 棋盘较高，T型方块最有利，其他方块相对不利
                        if (index !== 2) score += 10;
                    }
                    
                    // 根据方块形状的复杂性评估不利程度
                    // 例如：S型和Z型方块在某些情况下更难放置
                    if (index === 3 || index === 4) {
                        score += 5;
                    }
                    
                    // 添加一定的随机性，避免完全可预测
                    score += Math.random() * 2;
                    
                    return { index, score };
                });
                
                // 按分数排序
                pieceScores.sort((a, b) => b.score - a.score);
                
                // 引入概率选择机制，而不是总是选择得分最高的
                // 得分最高的方块有60%的概率被选中，第二高的有25%，第三高的有15%
                const random = Math.random();
                if (random < 0.6) {
                    return pieceScores[0].index;
                } else if (random < 0.85 && pieceScores.length > 1) {
                    return pieceScores[1].index;
                } else if (random < 1 && pieceScores.length > 2) {
                    return pieceScores[2].index;
                } else {
                    // 兜底情况，返回得分最高的
                    return pieceScores[0].index;
                }
            }
            
            // 修改创建新方块的函数，支持AI模式
            function createNewPiece() {
                let shapeIndex;
                
                if (isAIEnabled) {
                    // AI模式：获取对玩家最不利的方块
                    shapeIndex = getWorstPieceForPlayer();
                } else {
                    // 普通模式：随机方块
                    shapeIndex = Math.floor(Math.random() * SHAPES.length);
                }
                
                const shape = SHAPES[shapeIndex].shape;
                const color = SHAPES[shapeIndex].color;
                
                return {
                    shape: shape,
                    x: Math.floor(COLS / 2) - Math.floor(shape[0].length / 2),
                    y: 0,
                    color: color
                };
            }
            
            // 开始游戏循环
            gameInterval = requestAnimationFrame(gameLoop);
            
            // 教程模态框逻辑
            const tutorialModal = document.getElementById('tutorial-modal');
            const tutorialBtn = document.getElementById('tutorial-btn');
            const tutorialClose = document.querySelector('.tutorial-close');
            
            // AI切换按钮事件处理
            const aiToggleBtn = document.getElementById('ai-toggle');
            if (aiToggleBtn) {
                aiToggleBtn.addEventListener('click', function() {
                    if (isAIEnabled) {
                        disableAI();
                        this.textContent = '开启AI';
                    } else {
                        enableAI();
                        this.textContent = '关闭AI';
                    }
                });
            }
            
            if (tutorialBtn) {
                tutorialBtn.addEventListener('click', () => {
                    tutorialModal.classList.add('active');
                });
            }
            
            if (tutorialClose) {
                tutorialClose.addEventListener('click', () => {
                    tutorialModal.classList.remove('active');
                });
            }
            
            // 点击模态框外部关闭
            tutorialModal.addEventListener('click', (e) => {
                if (e.target === tutorialModal) {
                    tutorialModal.classList.remove('active');
                }
            });
            
            // 初始化游戏熟悉度系统
            if (window.gameFamiliaritySystem) {
                window.gameFamiliaritySystem.init('tetris', '俄罗斯方块');
            }
        });
    </script>
    <script src="../js/gameFamiliarity.js"></script>
</body>
</html>